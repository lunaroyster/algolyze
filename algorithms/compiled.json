[{"name":"A*","longName":"A* | A Star","url":"A*","tags":["pathfinding","graph search","graph traversal"],"description":"A* is a pathfinding algorithm that's used to plot an efficiently directed path between multiple points, using heuristics to guide its search and attain a better performance.","links":[{"name":"Wikipedia—A* search algorithm","url":"https://en.wikipedia.org/wiki/A*_search_algorithm","img":"images/Wikipedia's_W.svg"}]},{"name":"Bellman–Ford Algorithm","longName":"Bellman–Ford-Moore Algorithm","url":"Bellman–Ford-algorithm","tags":["pathfinding","graph search","graph traversal"],"description":"The Bellman-Ford Algorithm computes shortest distances from one source node to all other nodes in a weighted graph, where some links can be negative.","links":[{"name":"Wikipedia—Bellman-Ford algorithm","url":"https://en.wikipedia.org/wiki/Bellman–Ford_algorithm","img":"images/Wikipedia's_W.svg"}]},{"name":"Best-first Search","longName":"Best-first Search","url":"Best-first-Search","tags":["pathfinding","graph search","graph traversal"],"description":"Best-first search is a graph search algorithm that operates by picking the most promising node available by a chosen rule or heuristic.","links":[{"name":"Wikipedia—Best-first search","url":"https://en.wikipedia.org/wiki/Best-first_search","img":"images/Wikipedia's_W.svg"}]},{"name":"Binary Search","longName":"Binary search/half-interval search/logarithmic search/binary chop","url":"Binary-Search","tags":["search","logarithmic","sorted search"],"description":"Binary search works on sorted arrays. Binary search begins by comparing the middle element of the array with the target value. If the target value matches the middle element, its position in the array is returned. If the target value is less than or greater than the middle element, the search continues in the lower or upper half of the array, respectively, eliminating the other half from consideration","links":[{"name":"Wikipedia—Binary search algorithm","url":"https://en.wikipedia.org/wiki/Binary_search_algorithm","img":"images/Wikipedia's_W.svg"}]},{"name":"Boyer-Moore string search","longName":"Boyer–Moore string search algorithm","url":"Boyer-Moore-string-search","tags":["search","string","pattern"],"description":"Boyer-Moore string search processes the string/pattern being searched for, and uses that data to skip sections of the text. It's suitable in scenarios where the pattern is much shorter than the text.","links":[{"name":"Boyer–Moore string search algorithm","url":"https://en.wikipedia.org/wiki/Boyer–Moore_string_search_algorithm","img":"images/Wikipedia's_W.svg"}]},{"name":"Bubble Sort","longName":"Bubble Sort/Sinking Sort","url":"Bubble-Sort","tags":["sorting","comparision","bubble"],"description":"Bubblesort steps through an array comparing adjacent items, and swaps them if they are in the wrong order. It does this repeatedly until the array is sorted.","links":[{"name":"Wikipedia—Bubble sort","url":"https://en.wikipedia.org/wiki/Bubble_sort","img":"images/Wikipedia's_W.svg"}]},{"name":"Bucket Sort","longName":"Bucket Sort | bin sort","url":"Bucket-Sort","tags":["sorting","bucket","divide-and-conquer","distribution","radix-sort","comparision"],"description":"Bucket sort is a sorting algorithm that distributes the input elements into a number of buckets. Each bucket is sorted individually, either using another sorting algorithm, or by recursively applying the bucket sort algorithm.","links":[{"name":"Wikipedia—Bucket sort","url":"https://en.wikipedia.org/wiki/Bucket_sort","img":"images/Wikipedia's_W.svg"}]},{"name":"Comb Sort","longName":"Comb sort (Bubble Sort)","url":"Comb-Sort","tags":["sorting","comparision","comb","turtle","rabbit"],"description":"Comb sort improves upon bubble sort. It iterates through the array, comparing elements multiple spaces away, reducing the gap each iteration.","links":[{"name":"Wikipedia—Comb sort","url":"https://en.wikipedia.org/wiki/Comb_sort","img":"images/Wikipedia's_W.svg"}]},{"name":"Counting Sort","longName":"Counting Sort","url":"Counting-Sort","tags":["sorting","counting","integer"],"description":"Counting sort sorts objects according to small integer keys. It produces a frequency table from the input, and uses arithmetic to determine the position of elements in the output array.","links":[{"name":"Wikipedia—Counting sort","url":"https://en.wikipedia.org/wiki/Counting_sort","img":"images/Wikipedia's_W.svg"}]},{"name":"Cycle Sort","longName":"Cycle Sort","url":"Cycle-Sort","tags":["cycle","decomposition","comparison","in-place","unstable"],"description":"Cycle sort is an unstable, in-place sort that minimizes writes to the original array. It works by finding the cycle decomposition of the input and reverses it to put everything in place.","links":[{"name":"Wikipedia—Cycle Sort","url":"https://en.wikipedia.org/wiki/Cycle_sort","img":"images/Wikipedia's_W.svg"}]},{"name":"Dijkstra's Algorithm","longName":"Dijkstra's Algorithm","url":"Dijkstra's-Algorithm","tags":["pathfinding","graph search","graph traversal"],"description":"Dijkstra's Algorithm finds the shortest path between nodes on a graph. It's a special case of A*, using distance as a heuristic.","links":[{"name":"Wikipedia—Dijkstra's algorithm","url":"https://en.wikipedia.org/wiki/Dijkstra's_algorithm","img":"images/Wikipedia's_W.svg"}],"longDescription":"Dijkstra's algorithm is a pathfinding algorithm used to discover the shortest path between two points.\n\nBefore we describe the algorithm, let's define some things. The algorithm is run upon a network of **nodes** called a **graph**. The paths that connect the nodes together are called **edges**. The edges have **weights**.\n\nDijkstra's algorithm finds you the shortest distance between two nodes on the graph. It does this by iterating through the nodes and calculating the distance to reach their neighbors, and updating the *shortest known distance* if a shorter route is found.\n\nIn the worst case scenario, Dijkstra's Algorithm has a performance of O(|E| + |V|log|V|).\n\n## Pseudocode\n\n    function shortestPath(origin, destination, graph)\n        origin is set at 0 distance\n        other nodes are set at ∞\n        V = Visited nodes array, currently null\n        A = All nodes on graph, initially\n        while(A still has nodes):\n            m = <pop node from A with smallest distance>\n            add m to V\n            for each neighbor n of m:\n                newDistance = (shortest known distance from origin to m + distance from m to n)\n                knownDistance = (shortest known distance from origin to n)\n                if newDistance < knownDistance\n                    update n's shortest known distance from origin\n        return destination node's shortest known distance\n    end function"},{"name":"Exponential Search","longName":"Exponential search | doubling search | galloping search | Struzik search","url":"Exponential-Search","tags":["search","exponential","sorted search","binary search"],"description":"Exponential Search works on sorted lists. It repeatedly compares the target element to the element i, where i doubles each run. When the value of the target element is smaller than the element i, the required element is somewhere between the element i/2 and i. It then runs a binary search on this sublist to find the target element.","links":[{"name":"Wikipedia—Exponential search","url":"https://en.wikipedia.org/wiki/Exponential_search","img":"images/Wikipedia's_W.svg"}]},{"name":"Fibonacci Search","longName":"Fibonacci Search","url":"Fibonacci-Search","tags":["search","fibonacci","sorted search"],"description":"Fibonacci search works on sorted arrays with the aid of Fibonacci numbers. It divides the array into two parts that have sizes that are consecutive Fibonacci numbers.","links":[{"name":"Wikipedia—Fibonacci_search_technique","url":"https://en.wikipedia.org/wiki/Fibonacci_search_technique","img":"images/Wikipedia's_W.svg"}]},{"name":"Heapsort","longName":"Heapsort","url":"Heapsort","tags":["sorting","selection","in-place","heap"],"description":"Heapsort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. It's an improvement over Selection Sort, using heaps in the process.","links":[{"name":"Wikipedia—Heapsort","url":"https://en.wikipedia.org/wiki/Heapsort","img":"images/Wikipedia's_W.svg"}]},{"name":"Insertion Sort","longName":"Insertion sort","url":"Insertion-Sort","tags":["sorting","insertion"],"description":"Insertion sort builds a sorted array inserting items into the right location one at a time.","links":[{"name":"Wikipedia—Insertion Sort","url":"https://en.wikipedia.org/wiki/Insertion_sort","img":"images/Wikipedia's_W.svg"}],"longDescription":"Insertion Sort builds the final sorted array one item at a time. \n\nInsertion Sort iterates through a list, consuming one element each repetition, and **inserts** it into a growing sorted list.\n\nIn the worst case scenario (when the list is in a reverse sorted order), Insertion Sort iterates n^2 times for a list with n items. Its performance is quite good, however, in nearly sorted lists.\n\n## Pseudocode\n\n    function insertionSortArray(Array)\n        i = 1\n        while i < length(Array)\n            j = 1\n            while(j > 0 AND Array[j-1] > Array[j])\n                swap Array[j] and Array[j-1]\n                j = j - 1\n            end while\n            i++\n        end while\n        return Array\n    end function"},{"name":"Interpolation Search","longName":"Interpolation Search","url":"Interpolation-Search","tags":["search","sorted search"],"description":"Interpolation search uses the value of the target item to make a guess about its position in the array, and then searching nearby. It works well when the array is evenly distributed.","links":[{"name":"Wikipedia—Interpolation search","url":"https://en.wikipedia.org/wiki/Interpolation_search","img":"images/Wikipedia's_W.svg"}]},{"name":"Jump Search","longName":"Jump Search | Block Search","url":"Jump-Search","tags":["search","jump","block","sorted"],"description":"Jump search 'jumps' a fixed number of steps through a sorted array, and compares the term it lands on to the search term. If it finds an element lower than the search term, it performs a search in the sublist.","links":[{"name":"Wikipedia—Jump search","url":"https://en.wikipedia.org/wiki/Jump_search","img":"images/Wikipedia's_W.svg"}]},{"name":"Kruskal's Algorithm","longName":"Kruskal's algorithm","url":"Kruskal's-Algorithm","tags":["pathfinding","graph search","minimum spanning tree","greedy algorithm"],"description":"Kruskal's algorithm finds an edge of the least possible weight that connect two nodes in a graph, generating a minimum spanning tree.","links":[{"name":"Wikipedia—Kruskal's algorithm","url":"https://en.wikipedia.org/wiki/Kruskal%27s_algorithm","img":"images/Wikipedia's_W.svg"}]},{"name":"Linear Search","longName":"Linear/Sequential Search","url":"Linear-Search","tags":["search","linear","sequential"],"description":"Linear search sequentially checks each element of the list for the target value until a match is found or until all the elements have been searched","links":[{"name":"Wikipedia—Linear Search","url":"https://en.wikipedia.org/wiki/Linear_search","img":"images/Wikipedia's_W.svg"}]},{"name":"Merge Sort","longName":"Merge Sort","url":"Merge-Sort","tags":["sorting","comparision","recursive"],"description":"Merge sort takes advantage of the ease of merging already sorted lists into a new sorted list. It starts by comparing every two elements, swapping them if they are in the wrong order. It then merges the lists of two into lists of four, and so on.","links":[{"name":"Wikipedia—Merge Sort","url":"https://en.wikipedia.org/wiki/Merge_sort","img":"images/Wikipedia's_W.svg"}]},{"name":"Quicksort","longName":"Quicksort","url":"Quicksort","tags":["sorting","comparision","recursive"],"description":"Quicksort is a divide-and-conquer algorithm. It picks a partition point and splits an array into two parts—greater and smaller than the pivot. It then recursively sorts the two arrays with Quicksort, yielding a final sorted array.","links":[{"name":"Wikipedia—Quicksort","url":"https://en.wikipedia.org/wiki/Quicksort","img":"images/Wikipedia's_W.svg"}]},{"name":"Radix Sort","longName":"Radix Sort","url":"Radix-Sort","tags":["sorting","non-comparative","positional"],"description":"Radix sort operates on a list of integers. It compares the digits of the numbers at equivalent place values, and sorts them with a stable sorting algorithm. Since strings, dates, and other datatypes can be represented in positional notational systems, they can be also sorted with Radix sort","links":[{"name":"Wikipedia—Radix sort","url":"https://en.wikipedia.org/wiki/Radix_sort","img":"images/Wikipedia's_W.svg"}]},{"name":"Selection Sort","longName":"Selection sort","url":"Selection-Sort","tags":["sorting","selection","in-place"],"description":"The algorithm divides the input list into sorted and unsorted. The algorithm proceeds by finding the smallest  element in the unsorted sublist and swapping it with the first unsorted element after the sorted sublist, and moving the sublist boundaries one element to the right.","links":[{"name":"Wikipedia—Selection sort","url":"https://en.wikipedia.org/wiki/Selection_sort","img":"images/Wikipedia's_W.svg"}]},{"name":"Shellsort","longName":"Shell Sort | Shell's method","url":"Shellsort","tags":["sorting","comparision","bubble","insertion"],"description":"Shell Sort improves upon bubble sort and insertion sort by moving out of order elements more than one position at a time. It's quick at sorting mostly arranged lists.","links":[{"name":"Wikipedia—Shellsort","url":"https://en.wikipedia.org/wiki/Shellsort","img":"images/Wikipedia's_W.svg"}]}]
